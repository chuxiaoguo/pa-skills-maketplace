{
  "content": "\n# Next.js Cache Components\n\n> **Auto-activation**: This skill activates automatically in projects with `cacheComponents: true` in next.config.\n\n## Project Detection\n\nWhen starting work in a Next.js project, check if Cache Components are enabled:\n\n```bash\n# Check next.config.ts or next.config.js for cacheComponents\ngrep -r \"cacheComponents\" next.config.* 2>/dev/null\n```\n\nIf `cacheComponents: true` is found, apply this skill's patterns proactively when:\n\n- Writing React Server Components\n- Implementing data fetching\n- Creating Server Actions with mutations\n- Optimizing page performance\n- Reviewing existing component code\n\nCache Components enable **Partial Prerendering (PPR)** - mixing static HTML shells with dynamic streaming content for optimal performance.\n\n## Philosophy: Code Over Configuration\n\nCache Components represents a shift from **segment configuration** to **compositional code**:\n\n| Before (Deprecated)                     | After (Cache Components)                  |\n| --------------------------------------- | ----------------------------------------- |\n| `export const revalidate = 3600`        | `cacheLife('hours')` inside `'use cache'` |\n| `export const dynamic = 'force-static'` | Use `'use cache'` and Suspense boundaries |\n| All-or-nothing static/dynamic           | Granular: static shell + cached + dynamic |\n\n**Key Principle**: Components co-locate their caching, not just their data. Next.js provides build-time feedback to guide you toward optimal patterns.\n\n## Core Concept\n\n```\n┌─────────────────────────────────────────────────────┐\n│                   Static Shell                       │\n│  (Sent immediately to browser)                       │\n│                                                      │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │\n│  │   Header    │  │  Cached     │  │  Suspense   │  │\n│  │  (static)   │  │  Content    │  │  Fallback   │  │\n│  └─────────────┘  └─────────────┘  └──────┬──────┘  │\n│                                           │         │\n│                                    ┌──────▼──────┐  │\n│                                    │  Dynamic    │  │\n│                                    │  (streams)  │  │\n│                                    └─────────────┘  │\n└─────────────────────────────────────────────────────┘\n```\n\n## Mental Model: The Caching Decision Tree\n\nWhen writing a React Server Component, ask these questions in order:\n\n```\n┌─────────────────────────────────────────────────────────┐\n│ Does this component fetch data or perform I/O?          │\n└─────────────────────┬───────────────────────────────────┘\n                      │\n           ┌──────────▼──────────┐\n           │   YES               │ NO → Pure component, no action needed\n           └──────────┬──────────┘\n                      │\n    ┌─────────────────▼─────────────────┐\n    │ Does it depend on request context? │\n    │ (cookies, headers, searchParams)   │\n    └─────────────────┬─────────────────┘\n                      │\n         ┌────────────┴────────────┐\n         │                         │\n    ┌────▼────┐              ┌─────▼─────┐\n    │   YES   │              │    NO     │\n    └────┬────┘              └─────┬─────┘\n         │                         │\n         │                   ┌─────▼─────────────────┐\n         │                   │ Can this be cached?   │\n         │                   │ (same for all users?) │\n         │                   └─────┬─────────────────┘\n         │                         │\n         │              ┌──────────┴──────────┐\n         │              │                     │\n         │         ┌────▼────┐          ┌─────▼─────┐\n         │         │   YES   │          │    NO     │\n         │         └────┬────┘          └─────┬─────┘\n         │              │                     │\n         │              ▼                     │\n         │         'use cache'                │\n         │         + cacheTag()               │\n         │         + cacheLife()              │\n         │                                    │\n         └──────────────┬─────────────────────┘\n                        │\n                        ▼\n              Wrap in <Suspense>\n              (dynamic streaming)\n```\n\n**Key insight**: The `'use cache'` directive is for data that's the _same across users_. User-specific data stays dynamic with Suspense.\n\n## Quick Start\n\n### Enable Cache Components\n\n```typescript\n// next.config.ts\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n\nexport default nextConfig\n```\n\n### Basic Usage\n\n```tsx\n// Cached component - output included in static shell\nasync function CachedPosts() {\n  'use cache'\n  const posts = await db.posts.findMany()\n  return <PostList posts={posts} />\n}\n\n// Page with static + cached + dynamic content\nexport default async function BlogPage() {\n  return (\n    <>\n      <Header /> {/* Static */}\n      <CachedPosts /> {/* Cached */}\n      <Suspense fallback={<Skeleton />}>\n        <DynamicComments /> {/* Dynamic - streams */}\n      </Suspense>\n    </>\n  )\n}\n```\n\n## Core APIs\n\n### 1. `'use cache'` Directive\n\nMarks code as cacheable. Can be applied at three levels:\n\n```tsx\n// File-level: All exports are cached\n'use cache'\nexport async function getData() {\n  /* ... */\n}\nexport async function Component() {\n  /* ... */\n}\n\n// Component-level\nasync function UserCard({ id }: { id: string }) {\n  'use cache'\n  const user = await fetchUser(id)\n  return <Card>{user.name}</Card>\n}\n\n// Function-level\nasync function fetchWithCache(url: string) {\n  'use cache'\n  return fetch(url).then((r) => r.json())\n}\n```\n\n**Important**: All cached functions must be `async`.\n\n### 2. `cacheLife()` - Control Cache Duration\n\n```tsx\nimport { cacheLife } from 'next/cache'\n\nasync function Posts() {\n  'use cache'\n  cacheLife('hours') // Use a predefined profile\n\n  // Or custom configuration:\n  cacheLife({\n    stale: 60, // 1 min - client cache validity\n    revalidate: 3600, // 1 hr - start background refresh\n    expire: 86400, // 1 day - absolute expiration\n  })\n\n  return await db.posts.findMany()\n}\n```\n\n**Predefined profiles**: `'default'`, `'seconds'`, `'minutes'`, `'hours'`, `'days'`, `'weeks'`, `'max'`\n\n### 3. `cacheTag()` - Tag for Invalidation\n\n```tsx\nimport { cacheTag } from 'next/cache'\n\nasync function BlogPosts() {\n  'use cache'\n  cacheTag('posts')\n  cacheLife('days')\n\n  return await db.posts.findMany()\n}\n\nasync function UserProfile({ userId }: { userId: string }) {\n  'use cache'\n  cacheTag('users', `user-${userId}`) // Multiple tags\n\n  return await db.users.findUnique({ where: { id: userId } })\n}\n```\n\n### 4. `updateTag()` - Immediate Invalidation\n\nFor **read-your-own-writes** semantics:\n\n```tsx\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function createPost(formData: FormData) {\n  await db.posts.create({ data: formData })\n\n  updateTag('posts') // Client immediately sees fresh data\n}\n```\n\n### 5. `revalidateTag()` - Background Revalidation\n\nFor stale-while-revalidate pattern:\n\n```tsx\n'use server'\nimport { revalidateTag } from 'next/cache'\n\nexport async function updatePost(id: string, data: FormData) {\n  await db.posts.update({ where: { id }, data })\n\n  revalidateTag('posts', 'max') // Serve stale, refresh in background\n}\n```\n\n## When to Use Each Pattern\n\n| Content Type | API                 | Behavior                              |\n| ------------ | ------------------- | ------------------------------------- |\n| **Static**   | No directive        | Rendered at build time                |\n| **Cached**   | `'use cache'`       | Included in static shell, revalidates |\n| **Dynamic**  | Inside `<Suspense>` | Streams at request time               |\n\n## Parameter Permutations & Subshells\n\n**Critical Concept**: With Cache Components, Next.js renders ALL permutations of provided parameters to create reusable subshells.\n\n```tsx\n// app/products/[category]/[slug]/page.tsx\nexport async function generateStaticParams() {\n  return [\n    { category: 'jackets', slug: 'classic-bomber' },\n    { category: 'jackets', slug: 'essential-windbreaker' },\n    { category: 'accessories', slug: 'thermal-fleece-gloves' },\n  ]\n}\n```\n\nNext.js renders these routes:\n\n```\n/products/jackets/classic-bomber        ← Full params (complete page)\n/products/jackets/essential-windbreaker ← Full params (complete page)\n/products/accessories/thermal-fleece-gloves ← Full params (complete page)\n/products/jackets/[slug]                ← Partial params (category subshell)\n/products/accessories/[slug]            ← Partial params (category subshell)\n/products/[category]/[slug]             ← No params (fallback shell)\n```\n\n**Why this matters**: The category subshell (`/products/jackets/[slug]`) can be reused for ANY jacket product, even ones not in `generateStaticParams`. Users navigating to an unlisted jacket get the cached category shell immediately, with product details streaming in.\n\n### `generateStaticParams` Requirements\n\nWith Cache Components enabled:\n\n1. **Must provide at least one parameter** - Empty arrays now cause build errors (prevents silent production failures)\n2. **Params prove static safety** - Providing params lets Next.js verify no dynamic APIs are called\n3. **Partial params create subshells** - Each unique permutation generates a reusable shell\n\n```tsx\n// ❌ ERROR with Cache Components\nexport function generateStaticParams() {\n  return [] // Build error: must provide at least one param\n}\n\n// ✅ CORRECT: Provide real params\nexport async function generateStaticParams() {\n  const products = await getPopularProducts()\n  return products.map(({ category, slug }) => ({ category, slug }))\n}\n```\n\n## Cache Key = Arguments\n\nArguments become part of the cache key:\n\n```tsx\n// Different userId = different cache entry\nasync function UserData({ userId }: { userId: string }) {\n  'use cache'\n  cacheTag(`user-${userId}`)\n\n  return await fetchUser(userId)\n}\n```\n\n## Build-Time Feedback\n\nCache Components provides early feedback during development. These build errors **guide you toward optimal patterns**:\n\n### Error: Dynamic data outside Suspense\n\n```\nError: Accessing cookies/headers/searchParams outside a Suspense boundary\n```\n\n**Solution**: Wrap dynamic components in `<Suspense>`:\n\n```tsx\n<Suspense fallback={<Skeleton />}>\n  <ComponentThatUsesCookies />\n</Suspense>\n```\n\n### Error: Uncached data outside Suspense\n\n```\nError: Accessing uncached data outside Suspense\n```\n\n**Solution**: Either cache the data or wrap in Suspense:\n\n```tsx\n// Option 1: Cache it\nasync function ProductData({ id }: { id: string }) {\n  'use cache'\n  return await db.products.findUnique({ where: { id } })\n}\n\n// Option 2: Make it dynamic with Suspense\n;<Suspense fallback={<Loading />}>\n  <DynamicProductData id={id} />\n</Suspense>\n```\n\n### Error: Request data inside cache\n\n```\nError: Cannot access cookies/headers inside 'use cache'\n```\n\n**Solution**: Extract runtime data outside cache boundary (see \"Handling Runtime Data\" above).\n\n## Additional Resources\n\n- For complete API reference, see [REFERENCE.md](REFERENCE.md)\n- For common patterns and recipes, see [PATTERNS.md](PATTERNS.md)\n- For debugging and troubleshooting, see [TROUBLESHOOTING.md](TROUBLESHOOTING.md)\n\n## Code Generation Guidelines\n\nWhen generating Cache Component code:\n\n1. **Always use `async`** - All cached functions must be async\n2. **Place `'use cache'` first** - Must be first statement in function body\n3. **Call `cacheLife()` early** - Should follow `'use cache'` directive\n4. **Tag meaningfully** - Use semantic tags that match your invalidation needs\n5. **Extract runtime data** - Move `cookies()`/`headers()` outside cached scope\n6. **Wrap dynamic content** - Use `<Suspense>` for non-cached async components\n\n---\n\n## Proactive Application (When Cache Components Enabled)\n\nWhen `cacheComponents: true` is detected in the project, **automatically apply these patterns**:\n\n### When Writing Data Fetching Components\n\nAsk yourself: \"Can this data be cached?\" If yes, add `'use cache'`:\n\n```tsx\n// Before: Uncached fetch\nasync function ProductList() {\n  const products = await db.products.findMany()\n  return <Grid products={products} />\n}\n\n// After: With caching\nasync function ProductList() {\n  'use cache'\n  cacheTag('products')\n  cacheLife('hours')\n\n  const products = await db.products.findMany()\n  return <Grid products={products} />\n}\n```\n\n### When Writing Server Actions\n\nAlways invalidate relevant caches after mutations:\n\n```tsx\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function createProduct(data: FormData) {\n  await db.products.create({ data })\n  updateTag('products') // Don't forget!\n}\n```\n\n### When Composing Pages\n\nStructure with static shell + cached content + dynamic streaming:\n\n```tsx\nexport default async function Page() {\n  return (\n    <>\n      <StaticHeader /> {/* No cache needed */}\n      <CachedContent /> {/* 'use cache' */}\n      <Suspense fallback={<Skeleton />}>\n        <DynamicUserContent /> {/* Streams at runtime */}\n      </Suspense>\n    </>\n  )\n}\n```\n\n### When Reviewing Code\n\nFlag these issues in Cache Components projects:\n\n- [ ] Data fetching without `'use cache'` where caching would benefit\n- [ ] Missing `cacheTag()` calls (makes invalidation impossible)\n- [ ] Missing `cacheLife()` (relies on defaults which may not be appropriate)\n- [ ] Server Actions without `updateTag()`/`revalidateTag()` after mutations\n- [ ] `cookies()`/`headers()` called inside `'use cache'` scope\n- [ ] Dynamic components without `<Suspense>` boundaries\n- [ ] **DEPRECATED**: `export const revalidate` - replace with `cacheLife()` in `'use cache'`\n- [ ] **DEPRECATED**: `export const dynamic` - replace with Suspense + cache boundaries\n- [ ] Empty `generateStaticParams()` return - must provide at least one param\n",
  "files": [
    {
      "name": "SKILL.md",
      "path": "cache-components/SKILL.md",
      "type": "markdown",
      "relativePath": "SKILL.md"
    },
    {
      "name": "PATTERNS.md",
      "path": "cache-components/PATTERNS.md",
      "type": "markdown",
      "relativePath": "PATTERNS.md"
    },
    {
      "name": "REFERENCE.md",
      "path": "cache-components/REFERENCE.md",
      "type": "markdown",
      "relativePath": "REFERENCE.md"
    },
    {
      "name": "TROUBLESHOOTING.md",
      "path": "cache-components/TROUBLESHOOTING.md",
      "type": "markdown",
      "relativePath": "TROUBLESHOOTING.md"
    }
  ]
}